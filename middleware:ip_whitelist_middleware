package middlware

import (
	"encoding/json"
	"net/http"
	"strings"
	"sync"
)

var (
	whitelist = struct {
		IPs  []string
		lock sync.RWMutex
	}{IPs: []string{"127.0.0.1", "::1","["}}
)

func IPWhitelistMiddleware() func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			clientIP := strings.Split(r.RemoteAddr, ":")[0]

			// Safely check if the client IP is in the whitelist
			whitelist.lock.RLock()
			allowed := false
			for _, ip := range whitelist.IPs {
				if ip == clientIP {
					allowed = true
					break
				}
			}
			whitelist.lock.RUnlock()

			if !allowed {
				http.Error(w, "Access denied", http.StatusForbidden)
				return
			}

			next.ServeHTTP(w, r)
		})
	}
}

// Adds an IP to the whitelist
func AddIPHandler(w http.ResponseWriter, r *http.Request) {
	var ip struct {
		IP string `json:"ip"`
	}
	if err := json.NewDecoder(r.Body).Decode(&ip); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	whitelist.lock.Lock()
	whitelist.IPs = append(whitelist.IPs, ip.IP)
	whitelist.lock.Unlock()

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(whitelist.IPs)
}

// Removes an IP from the whitelist
func RemoveIPHandler(w http.ResponseWriter, r *http.Request) {
	var ip struct {
		IP string `json:"ip"`
	}
	if err := json.NewDecoder(r.Body).Decode(&ip); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	whitelist.lock.Lock()
	for i, whitelistIP := range whitelist.IPs {
		if ip.IP == whitelistIP {
			whitelist.IPs = append(whitelist.IPs[:i], whitelist.IPs[i+1:]...)
			break
		}
	}
	whitelist.lock.Unlock()

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(whitelist.IPs)
}